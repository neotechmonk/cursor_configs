# Architectural Rules

## 1. System Design Principles

### 1.1 Separation of Concerns
- **Rule**: Each module/component should have a single, well-defined responsibility
- **Why**: Prevents tight coupling and makes code easier to understand, test, and maintain
- **Example**: Separate data access, business logic, and presentation layers

### 1.2 Dependency Inversion
- **Rule**: High-level modules should not depend on low-level modules. Both should depend on abstractions
- **Why**: Enables loose coupling and easier testing through dependency injection
- **Example**: Use interfaces/abstract classes for external dependencies

### 1.3 Single Responsibility Principle
- **Rule**: A class/function should have only one reason to change
- **Why**: Reduces complexity and makes code more maintainable
- **Example**: Split large classes into smaller, focused ones

## 2. Code Organization
### 2.1 Modular Architecture
- **Rule**: Organize code into domain-driven modules with clear boundaries
- **Why**: Enables independent development, testing and deployment of modules
- **Example**: 
  ```
  src/
  ├── users/              # User domain module
  │   ├── adapters/       # External interfaces
  │   ├── domain/         # Core domain logic
  │   ├── infrastructure/ # Technical implementations
  │   └── ports/          # Module boundaries
  ├── orders/             # Order domain module
  │   ├── adapters/
  │   ├── domain/
  │   ├── infrastructure/
  │   └── ports/
  └── shared/             # Shared kernel
      ├── domain/         # Common domain models
      └── infrastructure/ # Shared technical concerns
  ```
### 2.1.1 Modular Decoupling
- **Rule**: Modules must not directly depend on other modules' internal implementations
- **Why**: Prevents tight coupling and enables modules to evolve independently
- **Example**: 
  ```python
  # Bad - direct dependency
  from users.domain.user import User
  
  # Good - through adapter/interface
  from users.ports.user_port import UserPort
  ```
- **Implementation**:
  - Use adapters/bridges for inter-module communication
  - Define clear interface contracts in ports
  - Hide internal module details
  - Dependency injection for cross-module features

### 2.2 Module Boundaries
- **Rule**: Define clear boundaries between modules with explicit interfaces

- **Why**: Prevents circular dependencies and enforces encapsulation
- **Example**: Use `__init__.py` files to define public APIs
  - should be sparingly be used only for public APIs

### 2.3 Configuration Management
- **Rule**: Separate configuration from code and use environment-specific configs
  - Always infer the nature of configuration management already used in the source code. Don't introduce new patterns
- **Why**: Enables different deployments without code changes
- **Example**: Use `.env` files, config classes, or dependency injection

## 3. Scalability & Performance

### 3.1 Horizontal Scaling
- **Rule**: Design for horizontal scaling from the start
- **Why**: Easier to scale out than scale up
- **Example**: Stateless services, shared databases, load balancers

### 3.3 Async Processing
- **Rule**: Assume async processing by default
- **Why**: Better resource utilization and responsiveness. This to reduce temporal dependency
- **Example**: Async/await patterns, message queues, background workers

