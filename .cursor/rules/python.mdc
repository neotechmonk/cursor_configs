---
description: Comprehensive guidelines for Python development, covering code organization, performance, security, testing, and more.  These rules promote maintainable, efficient, and secure Python codebases.
globs: *.py
---
# Python Best Practices and Coding Standards

This document outlines comprehensive best practices and coding standards for Python development, aiming to promote clean, efficient, maintainable, and secure code.

## 1. Code Organization and Structure

### 1.1. Directory Structure Best Practices

*   **Flat is better than nested (but not always).**  Start with a simple structure and refactor as needed.
*   **Packages vs. Modules:** Use packages (directories with `__init__.py`) for logical grouping of modules.
*   **src layout:** stored under `[root]\src`
*   
*   **Typical Project Structure:**

```    
    project_name/
    |__ .cursor # read only; no edits
    │   ├── rules/ # .mdc files
    │   ├── templates/ # .md files to be duplicated used by rules
    ├──project_mgmt # plans, feature briefs
    ├── src/
    │   ├── package_name/
    │   │   ├── __init__.py
    │   │   ├── module1.py
    │   │   ├── module2.py
    │   ├── main.py  # Entry point
    ├── tests/
    │   ├── conftest.py # sparingly used
    │   ├── test_module1.py
    │   ├── test_module2.py
    ├── docs/
    │   ├── conf.py
    │   ├── index.rst
    ├── .gitignore
    ├── pyproject.toml 
    ├── README.md
```
    

### 1.2. File Naming Conventions

*   **Modules:**  Lowercase, with underscores for readability (e.g., `my_module.py`).
*   **Packages:** Lowercase (e.g., `my_package`). Avoid underscores unless necessary.
*   **Tests:** Start with `test_` (e.g., `test_my_module.py`).
    *   Additional instructions on unit testing here `.cursor/rules/unit_test.mdc`

### 1.3. Module Organization Best Practices

*   **Single Responsibility Principle:** Each module should have a well-defined purpose.
*   **Imports:**
    *   Order: standard library, third-party, local.
    *   Absolute imports are generally preferred (e.g., `from my_package.module1 import function1`).
    *   Use explicit relative imports (`from . import sibling_module`) when dealing with complex package layouts where absolute imports are overly verbose or impractical.
*   **Constants:**  Define module-level constants in uppercase (e.g., `MAX_ITERATIONS = 100`).
*   **Dunder names:** `__all__`, `__version__`, etc. should be after the module docstring but before any imports (except `from __future__`).  Use `__all__` to explicitly define the public API.

### 1.4. Component Architecture Recommendations

*   **Layered Architecture:** Suitable for larger applications, separating concerns into presentation, business logic, and data access layers.
*   **Microservices:**  For very large applications, consider breaking the system into smaller, independent services.
*   **Hexagonal/Clean Architecture:** Emphasizes decoupling business logic from external dependencies like databases and frameworks.
*   **Dependency Injection:** Use dependency injection to improve testability and reduce coupling.

### 1.5. Code Splitting Strategies

*   **By Functionality:**  Split code into modules based on distinct functionalities (e.g., user management, data processing).
*   **By Layer:** Separate presentation, business logic, and data access code.
*   **Lazy Loading:** Use `importlib.import_module()` to load modules on demand, improving startup time.
*   **Conditional Imports:** Import modules only when needed, based on certain conditions.

## 2. Common Patterns and Anti-patterns

### 2.1. Design Patterns
*   **Prioritize Dependency Injection ** Use the frameworks mentioned in the dependency. E.g. `dependecy-injector`
*   **Singleton:**  Restrict instantiation of a class to one object.
*   **Factory:**  Create objects without specifying the exact class to be created.
*   **Observer:**  Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified.
*   **Strategy:**  Define a family of algorithms, encapsulate each one, and make them interchangeable.
*   **Decorator:**  Add responsibilities to objects dynamically.
*   **Context Manager:** Guarantees resources are properly cleaned up (e.g., files are closed).
*   ** Repository ** Design flexibility for different persistence sources through repository or adapter pattern. E.g. yaml vs DB config storage

### 2.2. Recommended Approaches for Common Tasks

*   **Data Validation:** Use libraries like `pydantic` or `pydantic-settings` 
    *   Prioritize built-in or extensions for validations over customer validators
*   **Reduce Boiler plate:** Use libraries like `dataclass`
*   **Efficient Data structures:** Prefer `slots`, `tuples`, `named tuples`, 
*   **Configuration Management:** Use libraries like `python-decouple`, `dynaconf` or standard library's `configparser` to manage environment-specific settings.
*   **Logging:** Use the `logging` module for structured logging. Configure log levels and handlers appropriately.
*   **Command-Line Interfaces:** Use `argparse`, `click` or `typer` for creating command-line interfaces.
*   **Asynchronous Programming:** Use `asyncio` for I/O-bound and concurrency problems.
*   **Guard clauses:** early in the functions or to differentiate safety from logic

### 2.3. Anti-patterns and Code Smells

*   **God Class:** A class that does too much.  Break it down into smaller, more focused classes.
*   **Shotgun Surgery:**  Making small changes to many different classes at once. Indicates poor cohesion.
*   **Spaghetti Code:**  Unstructured and difficult-to-follow code.  Refactor using well-defined functions and classes.
*   **Duplicate Code:**  Extract common code into reusable functions or classes (DRY - Don't Repeat Yourself).
*   **Avoid nested conditionals:** To improve readability
*   **Magic Numbers/Strings:**  Use named constants instead of hardcoded values. If beneficial offer the user to address the constants as configurable values
*   **Nested Callbacks:**  Avoid excessive nesting of callbacks. Use `async/await` or promises for better readability.
*   **Premature Optimization:** Don't optimize code before identifying bottlenecks.

### 2.4. State Management Best Practices

*   **Stateless Functions:** Prefer stateless functions where possible.
*   **Immutable Data:** Use immutable data structures to prevent accidental modification.
*   **Explicit State:**  Manage state explicitly using classes or data structures.  Avoid relying on global variables.
*   **Context Variables:** Use `contextvars` (Python 3.7+) for managing request-scoped state in asynchronous applications.
*   **Redux-like patterns:** Consider redux-like patterns for managing client-side and complex application state.

### 2.5. Error Handling Patterns

*   **Specific Exceptions:** Catch specific exceptions rather than broad `Exception` or `BaseException`.
*   **`try...except...finally`:** Use `finally` to ensure cleanup code is always executed.
*   **Context Managers:**  Use context managers (`with open(...) as f:`) for resource management.
*   **Logging Errors:** Log exceptions with complete traceback information.
    *   Always sanitize sensitive data
*   **Raising Exceptions:** Raise exceptions with informative error messages.
*   **Custom Exceptions:** Create custom exception classes for specific error conditions.
*   **Avoid using exceptions for control flow.** Exceptions should represent exceptional circumstances.

## 3. Performance Considerations

### 3.1. Optimization Techniques

*   **Profiling:**  Use `cProfile` to identify performance bottlenecks.
*   **Efficient Data Structures:**  Choose the right data structure for the task (e.g., `set` for membership testing, `dict` for lookups).
*   **List Comprehensions and Generators:**  Use list comprehensions and generator expressions for concise and efficient code.
*   **Vectorization with NumPy:**  Use NumPy for numerical computations, leveraging vectorized operations. Still honor the APIs of the functions or modules. E.g. if a given function's parameter has pd.dataframe honor that. but feel free to use `numpy` for internal performance reasons.
*   **Just-In-Time Compilation (JIT):**  Consider using JIT compilers like Numba for performance-critical code.
*   **Caching:** Implement caching mechanisms using `functools.lru_cache` or external caching libraries like Redis or Memcached.
*   **String Concatenation:** Use `''.join(iterable)` for efficient string concatenation.
*   **Avoid Global Variables:** Accessing local variables is faster than accessing global variables.
*   **Cython:** Use Cython to write C extensions for Python, improving performance.

### 3.2. Memory Management Considerations

*   **Garbage Collection:**  Understand Python's garbage collection mechanism.
*   **Object References:**  Be mindful of object references and circular dependencies, which can prevent garbage collection.
*   **Memory Profiling:** Use `memory_profiler` to identify memory leaks.
*   **Slots:** Use `__slots__` in classes to reduce memory footprint (disables `__dict__`).
*   **Generators:** Use generators for processing large datasets without loading them into memory.
*   **Data type sizing:** Use the most efficient data types possible to reduce memory use.

### 3.3. Rendering Optimization

*   N/A for core Python libraries. Relevant for GUI frameworks (e.g., Tkinter, PyQt, Kivy).
*   For web development with frameworks such as Django, Flask, or Pyramid, use efficient templating, caching and database query optimizations.

### 3.4. Bundle Size Optimization

*   N/A for core Python libraries. Relevant for web applications or when creating executable bundles.
*   Use tools like `PyInstaller` or `cx_Freeze` to create executable bundles.
*   Minimize dependencies to reduce bundle size.
*   Use code minification techniques.




## 5. Testing Approaches

### 5.1. Unit Testing Strategies

*   **Test Individual Units:** Test individual functions, classes, or modules in isolation.
*   **Test-Driven Development (TDD):** Write tests before writing code.
*   **Coverage:**  Aim for high test coverage for happy path
*   **Assertion Styles:** Use appropriate assertion methods (e.g., `assertEqual`, `assertTrue`, `assertRaises`).
*   **Boundary conditions:** Test boundary conditions and edge cases.
*   **Error conditions:** Test that exceptions are raised when appropriate.
*   Use additional guidelines in `.cursor/rules/unit_test.mdc` unit tets

### 5.2. Integration Testing Approaches

*   **Test Interactions:** Test the interactions between different modules or components.
*   **Database Testing:** Test database interactions.
*   **API Testing:** Test API endpoints.
*   **Mock External Services:** Use mocks to simulate external services during integration tests.
*   **Focus on key workflows.** Integration tests should exercise the most important user workflows.

### 5.3. End-to-End Testing Recommendations

*   **Test Entire System:** Test the entire system from end to end.
*   **User Perspective:** Write tests from the perspective of the user.
*   **Browser Automation:** Use browser automation tools like Selenium or Playwright.
*   **Real-World Scenarios:** Simulate real-world scenarios in end-to-end tests.
*   **Focus on critical paths.** End-to-end tests are expensive to write and maintain, so focus on the most critical paths.

### 5.4. Test Organization Best Practices

*   **Separate Test Directory:**  Keep tests in a separate `tests` directory.
*   **Mirror Source Structure:**  Mirror the source code structure in the test directory.
*   **Test Modules:** Create test modules for each source module.
*   **Test Classes:**  Use test classes to group related tests.
*   **Use a test runner:** Use `pytest` or `unittest` test runners.
*   **Use fixtures:** Utilize fixtures to setup and tear down resources for tests.

### 5.5. Mocking and Stubbing Techniques

*   **`unittest.mock`:** Use the `unittest.mock` module for mocking and stubbing.
*   **Patching:**  Use `patch` to replace objects with mocks during tests.
*   **Side Effects:**  Define side effects for mocks to simulate different scenarios.
*   **Mocking External Dependencies:** Mock external dependencies like databases, APIs, and file systems.
*   **Use dependency injection for testability.** Dependency injection makes it easier to mock dependencies.



### 6.2. Edge Cases

*   **Floating-Point Arithmetic:** Be aware of the limitations of floating-point arithmetic. Use `int` or `decimal` where possible
*   **Unicode Handling:** Handle Unicode strings carefully.
*   **File Encoding:**  Specify file encoding when reading and writing files.
*   **Time Zones:**  Handle time zones correctly and handle datetimes timezone aware where possible
*   **Resource limits:** Be aware of and handle system resource limits (e.g., file handles, memory).

### 6.3. Version-Specific Issues

*   **Python 2 vs. Python 3:** Be aware of the differences between Python 2 and Python 3.
*   **Syntax Changes:**  Be aware of syntax changes in different Python versions.
*   **Library Compatibility:**  Ensure that libraries are compatible with the Python version being used.
*   **Deprecated features.** Avoid using deprecated features.

### 6.4. Compatibility Concerns

<!-- *   **Operating Systems:** Test code on different operating systems (Windows, macOS, Linux). -->
<!-- *   **Python Implementations:**  Consider compatibility with different Python implementations (CPython, PyPy, Jython). -->
*   **Database Versions:** Ensure compatibility with different database versions.
*   **External Libraries:**  Be aware of compatibility issues with external libraries.

### 6.5. Debugging Strategies

*   **`pdb`:**  Use the `pdb` debugger for interactive debugging.
*   **Logging:**  Use logging to track program execution.
*   **Print Statements:** Use print statements for simple debugging. But print statements should be removed from finalised code
*   **Assertions:**  Use assertions to check for expected conditions.
*   **Profiling:** Use profilers to identify performance bottlenecks.
*   **Code Analysis Tools:** Use `ruff` for code analysis
*   **Remote debugging:** Use remote debugging tools when debugging code running on remote servers.

## 7. Tooling and Environment

### 7.1. Recommended Development Tools

*   **IDEs:** PyCharm, VS Code (with Python extension), Sublime Text.
*   **Virtual Environment Managers:** `uv` 
*   **Package Managers:** `uv` over `pip` (default), `conda`, `poetry`. Refer to `.cursor/rules/uv.mdc`  for additional guidelines
*   **Debuggers:** `pdb`, IDE debuggers.
*   **Profilers:** `cProfile`, `memory_profiler`.
*   **Linters:** `ruff` over `pylint`, `flake8`.
*   **Formatters:** `ruff` over `black`, `autopep8`, `YAPF`.
*   **Static Analyzers:** `mypy`, `pytype`.
*    **Notebook environments**: Jupyter Notebook, Jupyter Lab, Google Colab.

### 7.2. Build Configuration Best Practices

*   **`pyproject.toml`:**  Use `pyproject.toml` for build configuration (PEP 518, PEP 621).
*   **`setup.py`:**  Use `setup.py` for legacy projects (but prefer `pyproject.toml` for new projects).
*   **Dependency Management:**  Specify dependencies in `pyproject.toml` over `requirements.txt` 
*   **Virtual Environments:**  Use virtual environments to isolate project dependencies.
*   **Reproducible builds:** Ensure reproducible builds by pinning dependencies.




